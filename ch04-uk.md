# Розділ 04: Каррування

## Не Можу Жити, Якщо Жити Треба Без Тебе
Якось мій батько пояснив мені, що існують речі, без яких людина може спокійно жити до тих пір, поки їх не спробує. Наприклад - мікрохвильова піч. Або смартфони. Старші люди пригадають повноцінне і переповнене подіями життя без інтернету. А для мене одна з таких речей - карування.

Концепція проста: Ви можете викликати функцію з меншою кількістю аргументів, ніж вона очікує. Вона повертає іншу функцію, яка приймає решту аргументів. 

Ви можете обрати, чи викликати її з усіма аргументами одразу, чи просто згодувати аргументи один за одним.

```js
const add = x => y => x + y;
const increment = add(1);
const addTen = add(10);

increment(2); // 3
addTen(2); // 12
```

Ми створили функцію `add`, яка приймає один параметр та повертає функцію. Викликавши її, функція, яка буде повернена, запам'ятовує перший аргумент звідти за допомогою замикання. Викликавши її з обома аргументами за один раз - трохи болюче, але, ми можемо використати спеціальну допоміжну функцію, яка називається `curry`. Це спростить нам задачу у оголошенні та викликані функцій як вищенаведена.

Давайте налаштуємо кілька каррованних функцій для нашого задоволення. Відтепер ми будемо викликати нашу функцію `curry`, визначену в [Додатку А - Основна підтримка функцій](./appendix_a.md).

```js
const match = curry((what, s) => s.match(what));
const replace = curry((what, replacement, s) => s.replace(what, replacement));
const filter = curry((f, xs) => xs.filter(f));
const map = curry((f, xs) => xs.map(f));
```

Шаблон, який я використав, дуже простий, але також важливий. Я завбачливо розмістив дані, над якими ми проводимо дії (строка, масив), в якості останнього аргументу. Трохи згодом стане зрозуміло як і коли їх використовувати.

(Синтаксис `/r/g` — це регулярний вираз, що означає _знайти кожну літеру 'r'_. Читайте [більше про регулярні вирази](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), якщо цікаво.)

```js
match(/r/g, 'hello world'); // [ 'r' ]

const hasLetterR = match(/r/g); // x => x.match(/r/g)
hasLetterR('hello world'); // [ 'r' ]
hasLetterR('just j and s and t etc'); // null

filter(hasLetterR, ['rock and roll', 'smooth jazz']); // ['rock and roll']

const removeStringsWithoutRs = filter(hasLetterR); // xs => xs.filter(x => x.match(/r/g))
removeStringsWithoutRs(['rock and roll', 'smooth jazz', 'drum circle']); // ['rock and roll', 'drum circle']

const noVowels = replace(/[aeiou]/ig); // (r,x) => x.replace(/[aeiou]/ig, r)
const censored = noVowels('*'); // x => x.replace(/[aeiou]/ig, '*')
censored('Chocolate Rain'); // 'Ch*c*l*t* R**n'
```

Тут продемонстрована можливість "пре-завантажити" функцію з аргументом чи кількома, в певному порядку, щоб отримати нову функцію, яка пам'ятає ті аргументи.

Я пропоную вам запустити `npm install lodash`, скопіювати код зверху і запустити його в REPL. Ви також можете зробити це в браузері, де доступні lodash чи ramda. 
Я заохочую вас клонувати репозиторій Mostly Adequate (`git clone https://github.com/MostlyAdequate/mostly-adequate-guide.git`), скопіювати код вище і спробувати його в REPL. Функція curry, а також будь-що, що визначено в додатках, доступні в модулі `support/index.js`.

Як альтернатива, можете подивитись на опубліковану версію у `npm`:

```
npm install @mostly-adequate/support
```

## Більше Ніж Каламбур Чи Спеціальний Соус

Каррування корисне для багатьох речей. Ми можемо робити нові функції просто передаючи нашим базовим функціям деякі аргументи, як от наприклад в `hasLetterR`, `removeStringsWithoutRs` та `censored`.

Ми також маємо можливість трансформувати будь-яку функцію, що працює над одинарними елементами у функцію, котра працюватиме з масивами, просто огорнувши її `map`-ом:

```js
const getChildren = x => x.childNodes;
const allTheChildren = map(getChildren);
```

Передача у функцію меншої кількості аргументів аніж вона очікує - називається *часткове застосування*. Часткове застосування функції може прибрати багато шаблонного(пер.: _boiler plate_) коду. Розглянемо якою може бути вищенаведенна функція `allTheChildren` з некаррованним методом `map` з бібліотеки lodash (зауважте, що аргументи знаходяться у іншій послідовності):

```js
const allTheChildren = elements => map(elements, getChildren);
```

Як правило, ми не визначаємо функції, які працюють на масивах, тому що ми можемо просто викликати `map(getChildren)`. Це ж стосується `sort`, `filter` та іншиї функцій вищого порядку (*функція вищого порядку* - функція, яка приймає або повертає іншу функцію).

Коли ми говорили про *чисті функції*, ми сказали, що вони приймають одну вхідну величину і повертають одну вихідну. Каррування робить як раз це саме: кожен одинарний параметр повертає нову функцію, яка очікує на решту аргументів. А це якраз один на вході - один на виході.

І не важливо, чи вхідна величина є функцією - вона все одно класифікується як чиста. Ми дозволяємо більше ніж один аргумент за раз, проте, здається, що це лише для зручності і видалення додаткових `()`.


## В Завершення

Каррування дуже зручне і я отримую величезне задоволення використовуючи карровані функції на щоденних засадах. Це інструмент на моєму поясі, який робить програмування у функціональному стилі менш багатослівним і нудним.

Ми можемо зробити нову функцію, так би мовити "на льоту", просто передавши у функцію кілька аргументів і як бонус, ми збережемо визначення математичної функції, незважаючи на численні аргументи.

Давайте озброємось іншим важливим інструментом, який називається `compose`.

[Частина 05: Написання Коду За Допомогою Композиції](ch05-uk.md)

## Вправи

#### Примітка щодо вправ

Протягом книги ви можете зустріти розділ «Вправи» як цей. Вправи можна виконувати прямо у браузері, якщо ви читаєте з [Gitbook](https://mostly-adequate.gitbooks.io/mostly-adequate-guide) (рекомендовано).

Зверніть увагу, що для всіх вправ книги ви завжди маєте кілька допоміжних функцій у глобальному обсязі. Отже, все, що визначено в [Додатку А](./appendix_a.md),
[Додатку B](./appendix_b.md) та [Додатку C](./appendix_c.md), доступне для вас! І, якщо цього було недостатньо, деякі вправи також визначатимуть функції, специфічні для проблеми, яку вони представляють; фактично вважайте їх також доступними.

> Підказка: ви можете надіслати своє рішення, натиснувши `Ctrl + Enter` у вбудованому редакторі!

#### Виконання Вправ На Вашому Комп'ютері (Необов'язково)

Якщо ви віддаєте перевагу виконувати вправи безпосередньо у файлах, використовуючи власний редактор:

- клонуйте репозиторій (`git clone git@github.com:MostlyAdequate/mostly-adequate-guide.git`)
- перейдіть до розділу вправ (*exercises*) (`cd mostly-adequate-guide/exercises`)
- встановіть необхідні утиліти за допомогою [npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) (`npm install`)
- заповніть відповіді, змінюючи файли під назвою *exercise\_\** у відповідній папці розділу
- запустіть перевірку за допомогою npm (наприклад: `npm run ch04`)

Юніт-тести будуть запущені проти ваших відповідей і нададуть підказки у разі помилки. Між іншим, відповіді до вправ доступні у файлах під назвою *solution\_\**.

#### Давайте Попрактикуємось!

{% exercise %}  
Рефакторінг для видалення всіх аргументів шляхом часткового застосування функції.
  
{% initial src="./exercises/ch04/exercise_a.js#L3;" %}  
```js  
const words = str => split(' ', str);  
```  
  
{% solution src="./exercises/ch04/solution_a.js" %}  
{% validation src="./exercises/ch04/validation_a.js" %}  
{% context src="./exercises/support.js" %}  
{% endexercise %}  


---


{% exercise %}  
Рефакторінг для видалення всіх аргументів шляхом часткового застосування функцій.  
  
{% initial src="./exercises/ch04/exercise_b.js#L3;" %}  
```js  
const filterQs = xs => filter(x => match(/q/i, x), xs);
```  
  
{% solution src="./exercises/ch04/solution_b.js" %}  
{% validation src="./exercises/ch04/validation_b.js" %}  
{% context src="./exercises/support.js" %}  
{% endexercise %}  


---


Враховуючи наступну функцію:

```js  
const keepHighest = (x, y) => (x >= y ? x : y);  
```  

{% exercise %}  
Рефакторінг функції `max`, щоб вона не посилалася на жодні аргументи, використовуючи допоміжну функцію `keepHighest`.
  
{% initial src="./exercises/ch04/exercise_c.js#L7;" %}  
```js  
const max = xs => reduce((acc, x) => (x >= acc ? x : acc), -Infinity, xs);  
```  
  
{% solution src="./exercises/ch04/solution_c.js" %}  
{% validation src="./exercises/ch04/validation_c.js" %}  
{% context src="./exercises/support.js" %}  
{% endexercise %}  
